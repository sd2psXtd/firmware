#include "ps2_cardman.h"

#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <string.h>

#include "card_emu/ps2_sd2psxman.h"
#include "debug.h"
#include "game_db/game_db.h"
#include "hardware/timer.h"
#include "pico/multicore.h"
#include "ps2_dirty.h"
#include "psram/psram.h"
#include "sd.h"
#include "settings.h"

#define PS2_DEFAULT_CARD_SIZE PS2_CARD_SIZE_8M
#define BLOCK_SIZE            (512)
#define SECTOR_COUNT          (PS2_DEFAULT_CARD_SIZE / BLOCK_SIZE)

#define MEMORY_CARDS_PATH "MemoryCards"
#define PS2_CARDS_PATH MEMORY_CARDS_PATH "/PS2"

uint8_t available_sectors[SECTOR_COUNT / 8]; // bitmap
static uint8_t flushbuf[BLOCK_SIZE];
static int fd = -1;
int current_read_sector = 0, priority_sector = -1;

#define MAX_GAME_NAME_LENGTH (127)
#define MAX_PREFIX_LENGTH    (4)
#define MAX_SLICE_LENGTH     ( 10 * 1000 )

static int card_idx;
static int card_chan;
static bool needs_update;
static uint32_t card_size;
static cardman_cb_t cardman_cb;
static char folder_name[MAX_GAME_ID_LENGTH];
static uint64_t cardprog_start;
static int cardman_sectors_done;
static size_t cardprog_pos;

static ps2_cardman_state_t cardman_state;

static enum {
    CARDMAN_CREATE,
    CARDMAN_OPEN,
    CARDMAN_IDLE
} cardman_operation;


int ps2_cardman_write_sector(int sector, void *buf512) {
    if (fd < 0)
        return -1;

    if (sd_seek(fd, sector * BLOCK_SIZE) != 0)
        return -1;

    if (sd_write(fd, buf512, BLOCK_SIZE) != BLOCK_SIZE)
        return -1;

    return 0;
}

bool ps2_cardman_is_sector_available(int sector) {
    return available_sectors[sector / 8] & (1 << (sector % 8));
}

void ps2_cardman_mark_sector_available(int sector) {
    available_sectors[sector / 8] |= (1 << (sector % 8));
}

void ps2_cardman_set_priority_sector(int sector) {
    priority_sector = sector;
}

void ps2_cardman_flush(void) {
    if (fd >= 0)
        sd_flush(fd);
}

static void ensuredirs(void) {
    char cardpath[32];

    snprintf(cardpath, sizeof(cardpath), PS2_CARDS_PATH "/%s", folder_name);

    sd_mkdir(MEMORY_CARDS_PATH);
    sd_mkdir(PS2_CARDS_PATH);
    sd_mkdir(cardpath);

    if (!sd_exists(MEMORY_CARDS_PATH) || !sd_exists(PS2_CARDS_PATH) || !sd_exists(cardpath))
        fatal("error creating directories");
}

static const uint8_t block0[384] = {
    0x53, 0x6F, 0x6E, 0x79, 0x20, 0x50, 0x53, 0x32, 0x20, 0x4D, 0x65, 0x6D, 0x6F, 0x72, 0x79, 0x20, 0x43, 0x61, 0x72, 0x64, 0x20, 0x46, 0x6F, 0x72, 0x6D, 0x61,
    0x74, 0x20, 0x31, 0x2E, 0x32, 0x2E, 0x30, 0x2E, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x02, 0x00, 0x10, 0x00, 0x00, 0xFF, 0x00, 0x20, 0x00, 0x00,
    0x29, 0x00, 0x00, 0x00, 0xC7, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x03, 0x00, 0x00, 0xFE, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x02, 0x2B,
    0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x41, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF};

static const uint8_t block2000[128] = {
    0x09, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x0F, 0x00,
    0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00,
    0x16, 0x00, 0x00, 0x00, 0x17, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x19, 0x00, 0x00, 0x00, 0x1A, 0x00, 0x00, 0x00, 0x1B, 0x00, 0x00, 0x00, 0x1C, 0x00,
    0x00, 0x00, 0x1D, 0x00, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 0x00,
    0x23, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x25, 0x00, 0x00, 0x00, 0x26, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00};

static const uint8_t blockA400[512] = {
    0x27, 0x84, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x31, 0x0C, 0x18, 0x0A, 0xE6, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F,
    0x31, 0x0C, 0x18, 0x0A, 0xE6, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

static const uint8_t blockA600[512] = {
    0x26, 0xA4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x31, 0x0C, 0x18, 0x0A, 0xE6, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F,
    0x31, 0x0C, 0x18, 0x0A, 0xE6, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2E, 0x2E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

static void genblock(size_t pos, void *vbuf) {
    uint8_t *buf = vbuf;

    memset(buf, 0xFF, BLOCK_SIZE);

    if (pos == 0) {
        memcpy(buf, block0, sizeof(block0));
    } else if (pos == 0x2000) {
        memcpy(buf, block2000, sizeof(block2000));
    } else if (pos >= 0x2400 && pos < 0xA400) {
        for (size_t i = 0; i < BLOCK_SIZE / 4; ++i) {
            uint32_t val = 0x7FFFFFFF;
            memcpy(&buf[i * 4], &val, sizeof(val));
        }
        if (pos == 0x2400) {
            buf[0] = buf[1] = buf[2] = buf[3] = 0xFF;
        }
        if (pos == 0xA200) {
            memset(buf + 0x11C, 0xFF, BLOCK_SIZE - 0x11C);
        }
    } else if (pos == 0xA400) {
        memcpy(buf, blockA400, sizeof(blockA400));
    } else if (pos == 0xA600) {
        memcpy(buf, blockA600, sizeof(blockA600));
    }
}

static int next_sector_to_load() {
    if (priority_sector != -1) {
        if (ps2_cardman_is_sector_available(priority_sector))
            priority_sector = -1;
        else
            return priority_sector;
    }

    while (current_read_sector < SECTOR_COUNT) {
        if (!ps2_cardman_is_sector_available(current_read_sector))
            return current_read_sector++;
        else
            current_read_sector++;
    }

    return -1;
}

static void ps2_cardman_continue(void) {
    if (cardman_operation == CARDMAN_OPEN) {
        uint64_t slice_start = time_us_64();
        while (time_us_64() - slice_start < MAX_SLICE_LENGTH) {
            ps2_dirty_lock();
            int sector_idx = next_sector_to_load();
            if (sector_idx == -1) {
                ps2_dirty_unlock();
                cardman_operation = CARDMAN_IDLE;
                uint64_t end = time_us_64();
                printf("OK!\n");

                printf("took = %.2f s; SD read speed = %.2f kB/s\n", (end - cardprog_start) / 1e6, 1000000.0 * card_size / (end - cardprog_start) / 1024);

                break;
            }

            size_t pos = sector_idx * BLOCK_SIZE;
            if (sd_seek(fd, pos) != 0)
                fatal("cannot read memcard\nseek");

            if (sd_read(fd, flushbuf, BLOCK_SIZE) != BLOCK_SIZE)
                fatal("cannot read memcard\nread");

            psram_write_dma(pos, flushbuf, BLOCK_SIZE, NULL);
            psram_wait_for_dma();
            ps2_cardman_mark_sector_available(sector_idx);
            ps2_dirty_unlock();

            cardprog_pos = cardman_sectors_done * BLOCK_SIZE;

            if (cardman_cb)
                cardman_cb(100 * cardprog_pos / card_size);

            cardman_sectors_done++;
        }
    } else if (cardman_operation == CARDMAN_CREATE) {
        uint64_t slice_start = time_us_64();
        while (time_us_64() - slice_start < MAX_SLICE_LENGTH) {
            cardprog_pos = cardman_sectors_done * BLOCK_SIZE;
            if (cardprog_pos >= PS2_DEFAULT_CARD_SIZE) {
                cardman_operation = CARDMAN_IDLE;
                sd_flush(fd);
                uint64_t end = time_us_64();
                printf("OK!\n");
                printf("took = %.2f s; SD write speed = %.2f kB/s\n", (end - cardprog_start) / 1e6, 1000000.0 * PS2_DEFAULT_CARD_SIZE / (end - cardprog_start) / 1024);
                break;
            }
            ps2_dirty_lock();
            // read back from PSRAM to make sure to retain already rewritten sectors, if any
            psram_read_dma(cardprog_pos, flushbuf, BLOCK_SIZE, NULL);
            psram_wait_for_dma();

            if (sd_write(fd, flushbuf, BLOCK_SIZE) != BLOCK_SIZE)
                fatal("cannot init memcard");

            ps2_dirty_unlock();

            if (cardman_cb)
                cardman_cb(100 * cardprog_pos / card_size);

            cardman_sectors_done++;
        }
        
    }
}

void ps2_cardman_open(void) {
    char path[64];

    needs_update = false;

    ensuredirs();

    if (PS2_CM_STATE_BOOT == cardman_state)
        snprintf(path, sizeof(path), PS2_CARDS_PATH "/%s/BootCard.mcd", folder_name);
    else
        snprintf(path, sizeof(path), PS2_CARDS_PATH "/%s/%s-%d.mcd", folder_name, folder_name, card_chan);

    if (card_idx != PS2_CARD_IDX_SPECIAL) {
        /* this is ok to do on every boot because it wouldn't update if the value is the same as currently stored */
        settings_set_ps2_card(card_idx);
        settings_set_ps2_channel(card_chan);
    }

    printf("Switching to card path = %s\n", path);

    if (!sd_exists(path)) {
        cardman_operation = CARDMAN_CREATE;
        fd = sd_open(path, O_RDWR | O_CREAT | O_TRUNC);
        cardman_sectors_done = 0;
        cardprog_pos = 0;

        if (fd < 0)
            fatal("cannot open for creating new card");

        printf("create new image at %s... ", path);
        cardprog_start = time_us_64();

        // quickly generate and write an empty card into PSRAM so that it's immediately available, takes about ~0.6s
        for (size_t pos = 0; pos < PS2_DEFAULT_CARD_SIZE; pos += BLOCK_SIZE) {
            if (PS2_DEFAULT_CARD_SIZE == PS2_CARD_SIZE_8M)
                genblock(pos, flushbuf);
            else
                memset(flushbuf, 0xFF, BLOCK_SIZE);

            ps2_dirty_lock();
            psram_write_dma(pos, flushbuf, BLOCK_SIZE, NULL);

            psram_wait_for_dma();
            ps2_cardman_mark_sector_available(pos / BLOCK_SIZE);
            ps2_dirty_unlock();

            if (cardman_cb)
                cardman_cb(0);
        }
        
    } else {
        fd = sd_open(path, O_RDWR);
        cardman_operation = CARDMAN_OPEN;
        cardprog_pos = 0;
        cardman_sectors_done = 0;

        if (fd < 0)
            fatal("cannot open card");

        card_size = sd_filesize(fd);
        if ((card_size != PS2_CARD_SIZE_512K) && (card_size != PS2_CARD_SIZE_1M) && (card_size != PS2_CARD_SIZE_2M) && (card_size != PS2_CARD_SIZE_4M) &&
            (card_size != PS2_CARD_SIZE_8M))
            fatal("Card %d Channel %d is corrupted", card_idx, card_chan);

        /* read 8 megs of card image */
        printf("reading card (%lu KB).... ", (uint32_t)(card_size / 1024));
        cardprog_start = time_us_64();
        if (cardman_cb)
            cardman_cb(0);


        }
}

void ps2_cardman_close(void) {
    if (fd < 0)
        return;
    ps2_cardman_flush();
    sd_close(fd);
    fd = -1;
    current_read_sector = 0;
    priority_sector = -1;
    memset(available_sectors, 0, sizeof(available_sectors));
}

void ps2_cardman_set_channel(uint16_t chan_num) {
    if (chan_num != card_chan)
        needs_update = true;
    if ((PS2_CM_STATE_NORMAL == cardman_state) || (PS2_CM_STATE_GAMEID == cardman_state)) {
        if (chan_num <= CHAN_MAX && chan_num >= CHAN_MIN) {
            card_chan = chan_num;
        }
    } else {
        card_idx = settings_get_ps2_card();
        card_chan = settings_get_ps2_channel();
        cardman_state = PS2_CM_STATE_NORMAL;
        snprintf(folder_name, sizeof(folder_name), "Card%d", card_idx);
    }
}

void ps2_cardman_next_channel(void) {
    if ((PS2_CM_STATE_NORMAL == cardman_state) || (PS2_CM_STATE_GAMEID == cardman_state)) {
        card_chan += 1;
        if (card_chan > CHAN_MAX)
            card_chan = CHAN_MIN;
    } else {
        card_idx = settings_get_ps2_card();
        card_chan = settings_get_ps2_channel();
        cardman_state = PS2_CM_STATE_NORMAL;
        snprintf(folder_name, sizeof(folder_name), "Card%d", card_idx);
    }
    needs_update = true;
}

void ps2_cardman_prev_channel(void) {
    if ((PS2_CM_STATE_NORMAL == cardman_state) || (PS2_CM_STATE_GAMEID == cardman_state)) {
        card_chan -= 1;
        if (card_chan < CHAN_MIN)
            card_chan = CHAN_MAX;
    } else {
        card_idx = settings_get_ps2_card();
        card_chan = settings_get_ps2_channel();
        cardman_state = PS2_CM_STATE_NORMAL;
        snprintf(folder_name, sizeof(folder_name), "Card%d", card_idx);
    }
    needs_update = true;
}

void ps2_cardman_set_idx(int idx_num) {
    if (idx_num != card_idx) needs_update = true;

    if (idx_num >= IDX_MIN) {
      if (idx_num <= UINT16_MAX){
        card_idx = idx_num;
        card_chan = CHAN_MIN;
        cardman_state = PS2_CM_STATE_NORMAL;
        snprintf(folder_name, sizeof(folder_name), "Card%d", card_idx);
      }
    }else if (idx_num == PS2_CARD_IDX_SPECIAL){
      card_idx = PS2_CARD_IDX_SPECIAL;
      card_chan = CHAN_MIN;
      cardman_state = PS2_CM_STATE_BOOT;
      snprintf(folder_name, sizeof(folder_name), "BOOT");
    }else{
      card_idx = ps2_cardman_set_folder_name_for_gameid_with_idx(idx_num);
      card_chan = CHAN_MIN;
      cardman_state = PS2_CM_STATE_GAMEID;
    }
}

void ps2_cardman_next_idx(void) {
    int newIdx = card_idx + 1;
    {
        card_chan = CHAN_MIN;
        if (newIdx == IDX_MIN || ps2_cardman_card_with_idx_exists(newIdx-1)){
          card_idx = (newIdx > (int)UINT16_MAX) ? UINT16_MAX : newIdx;
          cardman_state = PS2_CM_STATE_NORMAL;
          snprintf(folder_name, sizeof(folder_name), "Card%d", card_idx);
        }else{
          if (newIdx > IDX_MIN) newIdx = INT16_MIN;
          card_idx = ps2_cardman_set_folder_name_for_gameid_with_idx(newIdx);
          if (card_idx == PS2_CARD_IDX_SPECIAL) {
            cardman_state = PS2_CM_STATE_BOOT;
            snprintf(folder_name, sizeof(folder_name), "BOOT");
          }else{
            cardman_state = PS2_CM_STATE_GAMEID;
          }
        }
    }
    needs_update = true;
}

void ps2_cardman_prev_idx(void) {
    int newIdx = card_idx - 1;
    {
      card_chan = CHAN_MIN;
      card_idx = newIdx;
      if (newIdx >= IDX_MIN){
        cardman_state = PS2_CM_STATE_NORMAL;
      }else if (newIdx == PS2_CARD_IDX_SPECIAL){
        cardman_state = PS2_CM_STATE_BOOT;
      }else{
        card_idx = ps2_cardman_set_folder_name_for_gameid_with_idx(newIdx);
        if (card_idx == newIdx){
          cardman_state = PS2_CM_STATE_GAMEID;
        }else{
          for (card_idx = 1; card_idx<UINT16_MAX; card_idx++){
            if (!ps2_cardman_card_with_idx_exists(card_idx)) break;
          }
          snprintf(folder_name, sizeof(folder_name), "Card%d", card_idx);
          cardman_state = PS2_CM_STATE_NORMAL;
        }
      }
    }
    needs_update = true;
}

int ps2_cardman_get_idx(void) {    
    return (cardman_state == PS2_CM_STATE_BOOT) ? PS2_CARD_IDX_SPECIAL : card_idx;
}

int ps2_cardman_get_channel(void) {
    return card_chan;
}

void ps2_cardman_set_gameid(const char *const card_game_id) {
    if (!settings_get_ps2_game_id())
        return;

    char new_folder_name[MAX_GAME_ID_LENGTH];
    if (card_game_id[0]) {
        snprintf(new_folder_name, sizeof(new_folder_name), "%s", card_game_id);
        if ((strcmp(new_folder_name, folder_name) != 0) 
            || (PS2_CM_STATE_GAMEID != cardman_state)){
            card_idx = PS2_CARD_IDX_SPECIAL;
            cardman_state = PS2_CM_STATE_GAMEID;
            card_chan = CHAN_MIN;
            snprintf(folder_name, sizeof(folder_name), "%s", card_game_id);
            needs_update = true;
        }
    }
}

void ps2_cardman_set_progress_cb(cardman_cb_t func) {
    cardman_cb = func;
}

char *ps2_cardman_get_progress_text(void) {
    static char progress[32];

    if (cardman_operation != CARDMAN_IDLE)
        snprintf(progress, sizeof(progress), "%s %.2f kB/s", cardman_operation == CARDMAN_CREATE ? "Wr" : "Rd", 1000000.0 * cardprog_pos / (time_us_64() - cardprog_start) / 1024);
    else
        snprintf(progress, sizeof(progress), "Switching...");

    return progress;
}

uint32_t ps2_cardman_get_card_size(void) {
    return card_size;
}

const char *ps2_cardman_get_folder_name(void) {
    return folder_name;
}

ps2_cardman_state_t ps2_cardman_get_state(void) {
    return cardman_state;
}

bool ps2_cardman_needs_update(void) {
    return needs_update;
}

bool ps2_cardman_is_idle(void) {
    return cardman_operation == CARDMAN_IDLE;
}

void ps2_cardman_init(void) {
    if (settings_get_ps2_autoboot()) {
        card_idx = PS2_CARD_IDX_SPECIAL;
        cardman_state = PS2_CM_STATE_BOOT;
        card_chan = CHAN_MIN;
        snprintf(folder_name, sizeof(folder_name), "BOOT");
    } else {
        card_idx = settings_get_ps2_card();
        card_chan = settings_get_ps2_channel();
        cardman_state = PS2_CM_STATE_NORMAL;
        snprintf(folder_name, sizeof(folder_name), "Card%d", card_idx);
    }
    cardman_operation = CARDMAN_IDLE;
}

void ps2_cardman_task(void) {
    ps2_cardman_continue();
}

bool ps2_cardman_card_with_idx_exists(int idx){
  char cardpath[0x80] = {};
  snprintf(cardpath, sizeof(cardpath), PS2_CARDS_PATH "/Card%d", idx);
  return sd_exists(cardpath);
}

int ps2_cardman_set_folder_name_for_gameid_with_idx(int idx){
  if (idx >= 0) return 0;
  int retval = 0;

  int dir_fd = -1;
  int it_fd = -1;

  char filename[MAX_GAME_NAME_LENGTH] = {};

  dir_fd = sd_open(PS2_CARDS_PATH, O_RDONLY);
  if (dir_fd != -1) {
    for (it_fd = sd_iterate_dir(dir_fd, it_fd); it_fd != -1; it_fd = sd_iterate_dir(dir_fd, it_fd)) {
      sd_get_name(it_fd, filename, MAX_GAME_NAME_LENGTH);

      if (filename[0] == '.') continue;
      if (strcmp(filename, "BOOT") == 0) continue;
      if (strncmp(filename, "Card", 4) == 0) continue;

      snprintf(folder_name, sizeof(folder_name), "%s", filename);
      if (--retval == idx) break;
    }
  }

//out:
  if (it_fd != -1){
    sd_close(it_fd); it_fd = -1;
  }
  if (dir_fd != -1){
    sd_close(dir_fd); dir_fd = -1;
  }
  return retval;
}